<html>
<head>
    <title>Welcome to Example.com!</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
<h1>Success! The example.com server block is working!</h1>
<input type="text" id="message">
<button onclick="sendMessage()">Send</button>
<style>
    video {
        width: 420px;
    }
</style>
<video id="localVideo" playsinline autoplay muted></video>

<script src="dist/app.bundle.js"></script>
<script src="load.js"></script>
</body>
<!--
<script>
  const messageInput = document.querySelector('#message');
  let localStream, remoteStream;
  let pc1, pc2;
  const sendMessage = (event) => {
    const message = messageInput.value;
    messageInput.value = '';
    try {
      if (message)
        ws.webSocket.send(JSON.stringify({sender: 'Gela', message: message}));
    } catch (e) {

    }
  };

  class CibWebsocket extends HTMLElement {
    static get is() {
      return 'cib-web-socket';
    }

    constructor() {
      super();
      this._isOpen = false;
    }

    get isOpen() {
      return this._isOpen;
    }

    connectedCallback() {
      if (0 < CibWebsocket._instanceCount) {
        console.error('no more than one instance of cib-websocket should exist');
        return;
      }
      this.webSocket = new WebSocket(`ws${window.location.protocol.replace('http', '')}//${window.location.host}/ws/`);
      this.webSocket.onopen = () => {
        this._isOpen = true;
        this.dispatchEvent(new CustomEvent('open'));
      };
      this.webSocket.addEventListener('message',
          this._messageReceived.bind(this));
      CibWebsocket._instanceCount++;
    }

    _messageReceived(event) {
      try {
        const object = JSON.parse(event.data);
        this.dispatchEvent(new CustomEvent('message', {detail: object}));
      } catch (e) {
        console.error('Invalid JSON received from WebSocket', e);
      }
    }
  }

  CibWebsocket._instanceCount = 0;
  customElements.define(CibWebsocket.is, CibWebsocket);

  let ws = document.querySelector('#WebSocket');
  if (!ws) {
    ws = new CibWebsocket;
    ws.setAttribute('id', 'WebSocket');
    document.body.appendChild(ws);
  }
  ws.addEventListener('open', (event) => {
    ws.webSocket.send(JSON.stringify({type: 'create', room: window.room}));
    liveService.turnOnVideo();
  });
  ws.addEventListener('message', (event) => {
    if (event.detail && event.detail.type === 'READY') return;

    const message = event.detail;
    // console.log(message);
    if (message.type === 'close') {
      // window.alert('Room closed');
      liveService.stop();
    } else if (message.type === 'created') {
      window.isSender = true;
    } else if (message.type === 'joined') {
      window.isChannelReady = true;
    } else if (message.type === 'media') {
      liveService.setupPeerConnection();
    } else if (message.type === 'offer') {
      console.log('Receive Offer');
      if (!window.isSender && !liveService.isStarted) {
        liveService.setupPeerConnection();
      }
      liveService.peerConnection.setRemoteDescription(new RTCSessionDescription(message)).then(() => {
        liveService.answer();
      }).catch((error) => {
        console.error('Error while setting setRemoteDescription Offer', error);
      });
    } else if (message.type === 'answer' && liveService.isStarted) {
      console.log('Receive Answer');
      liveService.peerConnection.setRemoteDescription(new RTCSessionDescription(message)).then(() => {
        console.log('Sender successfully set answer');
      }).catch((error) => {
        console.log('error while setting answer', error);
      });
    } else if (message.type === 'candidate' && liveService.isStarted) {
      const candidate = new RTCIceCandidate({
        sdpMLineIndex: message.label,
        candidate: message.candidate,
      });
      liveService.peerConnection.addIceCandidate(candidate);

    } else if (message === 'bye' && liveService.isStarted) {
      liveService.stop();
    }
  });

  const configuration = {
    iceServers: [
      {urls: 'stun:re-su-dom.ga:5349'},
      {
        urls: 'turn:re-su-dom.ga:5349',
        username: 'turnAdmin',
        credential: '3u5p6omh5d8rr2c27mua6ojfqepdbnniotj2e2kv9ri',
      },
    ],
  };

  const getVideoStream = () => {
    if (isMobile()) {
      return navigator.mediaDevices.getUserMedia({audio: true, video: true});
    }
    if (navigator.getDisplayMedia) {
      return navigator.getDisplayMedia({video: true});
    } else if (navigator.mediaDevices.getDisplayMedia) {
      return navigator.mediaDevices.getDisplayMedia({video: true});
    } else {
      return navigator.mediaDevices.getUserMedia({video: {mediaSource: 'screen'}});
    }
  };

  function isMobile() {
    if (navigator.userAgent.match(/Android/i)
        || navigator.userAgent.match(/webOS/i)
        || navigator.userAgent.match(/iPhone/i)
        || navigator.userAgent.match(/iPad/i)
        || navigator.userAgent.match(/iPod/i)
        || navigator.userAgent.match(/BlackBerry/i)
        || navigator.userAgent.match(/Windows Phone/i)
    ) {
      return true;
    } else {
      return false;
    }
  }

  class liveService {
    static turnOnVideo() {
      console.log('Requesting local stream');
      liveService.localStream = null;
      liveService.remoteStream = null;
      let streamPromise = null;
      streamPromise = getVideoStream();
      // const streamPromise = navigator.mediaDevices.getDisplayMedia({video: true});
      // const streamPromise = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
      streamPromise.then((stream) => {
        console.log('Received local stream');
        liveService.localStream = stream;
        localVideo.srcObject = stream;
        ws.webSocket.send(JSON.stringify({type: 'media'}));
        if (window.isSender) {
          liveService.setupPeerConnection();
        }
      }).catch((e) => {
        alert(`getUserMedia() error: ${e.name}`);
      });

    }

    static setupPeerConnection() {
      if (!liveService.isStarted && typeof liveService.localStream !== 'undefined' && window.isChannelReady) {
        liveService.peerConnection = new RTCPeerConnection(configuration);
        liveService.peerConnection.addEventListener('icecandidate', (event) => {
          if (event.candidate) {
            const sendObject = {
              type: 'candidate',
              label: event.candidate.sdpMLineIndex,
              id: event.candidate.sdpMid,
              candidate: event.candidate.candidate,
            };
            ws.webSocket.send(JSON.stringify(sendObject));
          }
        });
        liveService.peerConnection.addEventListener('addstream', (event) => {
          // liveService.remoteStream = event.stream;
          const video = document.createElement('video');
          document.querySelector('#localVideo').parentNode.append(video);
          video.setAttribute('playsinline', '');
          video.setAttribute('autoplay', '');
          video.setAttribute('muted', '');
          video.srcObject = event.stream;
        });
        liveService.peerConnection.addEventListener('removestream', (event) => {
        });
        liveService.peerConnection.addStream(liveService.localStream);
        liveService.isStarted = true;
        if (window.isSender) {
          liveService.call();
        }
      }
    }

    static call() {
      liveService.peerConnection.createOffer().then((offerDescription) => {
        liveService.peerConnection.setLocalDescription(offerDescription).then(() => {
          ws.webSocket.send(JSON.stringify(offerDescription));

        });
      });
    }

    static answer() {
      liveService.peerConnection.createAnswer().then((answerDescription) => {

        liveService.peerConnection.setLocalDescription(answerDescription).then(() => {

        }).catch((error) => {
          console.log('Error while setLocalDescription', error);
        });
        ws.webSocket.send(JSON.stringify(answerDescription));
      });
    }

    static stop() {
      liveService.isStarted = false;
      liveService.peerConnection.close();
      liveService.peerConnection = null;
      localVideo.srcObject = null;
    }
  }


</script>
-->
</html>
